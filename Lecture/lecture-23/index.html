<!-- 
Lecture 23: JavaScript Objects - References and Copying - Garbage Collection

0. Objects
- as we know, there are 8 data types in JavaScript: string, number, bigint, boolean, null,
undefined, object, and symbol.
- seven of them are called "primitive" types, because their values contain only one single 
thing.
- objects are a non-primitive type, they are used to store keyed collections of various 
data and more complex entities.
- objects penetrate almost all aspects of the language.
- an object can be created using figure brackets `{}`. with an optional list of properties.
a property is a "key: value" pair, where the key is a string (also called property name) 
and value can be anything.
- an empty object can be created using one of two syntaxes: `{}` or `new Object()`.

1. Literals and Properties
- we can immediately create an object using `{}` and add properties to it.
- a property has a key (also know as name or identifier) before the colon `:` and a value 
to the right of it.
- to remove a property, we can use the `delete` operator.
- we can use multi-word property names, but then they must be quoted.

2. Square Brackets
- we can access a property using square brackets `[]` with a quoted property name. and we 
have to for multi-word property names.
- square brackets also provides a way to obtain the property as the result of an expression. the dot notation can not be used for that.

3. Computed Properties
- we can use square brackets in an object literal when create an object. That is called 
computed properties.

4. Property Value Short-Hand

5. Property Names Limitations

6. Property Existence Test: `in` Operator
- a notable feature of objects in JavaScript, compared to other languages, is that it is 
possible to access any property. There will be no error if the property does not exist.
- reading a non-existent property will just returns `undefined`.
- there is also a special operator `in` that can be used to check if a property exists in 
an object. `"key" in object`.

7. The `for...in` Loop
- to walk over all keys of an object, there exists a special form of the loop called 
`for...in`.

8. Ordered Like An Object
- objects are ordered in a special fashion, integers properties are sorted, others appear 
in creation order.

9. Tasks

10. Object References and Copying
- one of the fundamental differences between objects versus primitives is that object are 
stored and copied by reference, not by value, whereas primitives are copied as a whole 
value.
- objects are stored somewhere in memory, and the reference to that memory location is 
stored in the variable.
- when an object is copied, the reference to the original object is copied, but the object
itself is not copied or duplicated.

11. Comparison of Objects

12. Const Objects Can Be Modified

13. Cloning and Merging Objects
- what if we need to duplicate an object?
- we can use the `for...in` or `Object.assign` function to do that.
- we can create a new object and replicate the structure of the existing one, by iterating 
over its keys and copying them on the primitive level.
- we can also use the `Object.assign` function which takes two or more objects as arguments
and returns a new object with the properties of the objects merged into it.

14. Deep Cloning
- what if there are properties that are objects themselves?
- to make two objects truly separate, we should use a cloning loop that examines each key's
value and if it is an object, then replicate its structure as well. this is called deep cloning or structured cloning.
- there is `structuredClone` function that implements deep cloning.

15. Garbage Collection
- memory management in JavaScript is performed automatically and invisibly to us. we create 
primitives, objects, functions... all that takes memory.
- what happens when something is not needed anymore? how does JavaScript engine discover it 
and clean it up?
- the main concept of memory management in JavaScript is reachability.
- simply put, "reachable" values are those that are accessible or usable somehow. they are 
guaranteed to be stored in memory.

A) there is a base set of inherently reachable values, they can not be deleted for obvious 
reasons:
1. the currently executing function, its local variables and parameters.
2. other functions on the current chain of nested calls, their local variables and 
parameters.
3. global variables.
4. others - we will explain them later.

- these values are called "roots".

B) any other value is considered reachable if it is from a root by a reference or by a 
chain of references.

16. Internal Algorithms
- the basic garbage collection algorithm is called "mark and sweep".
1. the garbage collector takes roots and "marks" remember them.
2. then it visits and "marks" all the references from them.
3. then it visits marked objects and marks their references. all visited objects are 
remembered, so as not to visit the same object twice in the future.
4. ...and so on until every reachable (from the roots) references are visited.
5. all objects except marked ones are deleted.

- that is the concept of how garbage collection works. JavaScript engines apply many 
optimizations to make it run faster and do not introduce any delays in the code execution.

- some of the optimizations are:
1. generational collection.
2. incremental collection.
3. idle-time collection.

17. Object Methods, `this` Keyword
- objects are usually created to represent entities of the real world, such as users, 
orders, etc.
- and in the real world, the user can act: select something from the shopping cart, log in, 
log out, etc.
- actions are represented in JavaScript by function. -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lecture 23: JavaScript Objects</title>
  </head>
  <body>
    <script src="index.js"></script>
  </body>
</html>
